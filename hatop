#!/usr/bin/env python
#
# Copyright (C) 2010 John Feuerstein <john@feurix.com>
#
#   Project URL: http://feurix.org/projects/hatop/
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
'''
HATop is an interactive ncurses client for the HAProxy stats socket
===================================================================

HATop's appearance is similar to top(1). It supports various modes
for detailed statistics of all configured proxies and services in near
realtime. In addition, it features an interactive CLI for the haproxy
unix socket. This allows administrators to control the given haproxy
instance (change server weight, put servers into maintenance mode, ...)
directly out of hatop and monitor the results immediately.

Note: It is important to understand that when multiple haproxy processes
      are started on the same socket, any process may pick up the request
      and thus hatop will output stats owned solely by that process.
      The current haproxy-internal process id is displayed top right.

Key Mode    Description

1   STATUS  The default mode with health, session and queue statistics
2   TRAFFIC Display connection and request rates as well as traffic stats
3   HTTP    Display various statistical information related to HTTP
4   ERRORS  Display health info, various error counters and downtimes
5   CLI     Display embedded command line client for the unix socket
Hh? HELP    Display this help screen
Qq  -       Quit

Header reference:

Node        configured name of the haproxy node
Uptime      runtime since haproxy was initially started
Pipes       pipes are currently used for kernel-based tcp slicing
Processes   number of haproxy processes
Tasks       number of actice process tasks
Run Queue   number of queued process tasks

In multiple modes:

NAME        name of the proxy and his services
WEIGHT      configured weight of the service
STATUS      service status (UP/DOWN/NOLB/MAINT/MAINT(via)...)
CHECK       status of last health check (see status reference below)

In STATUS mode:

ACT         server is active (server), number of active servers (backend)
BCK         server is backup (server), number of backup servers (backend)
QCUR        current queued requests
QMAX        max queued requests
SCUR        current sessions
SMAX        max sessions
SLIM        sessions limit
STOT        total sessions

In TRAFFIC mode:

LBTOT       total number of times a server was selected
RATE        number of sessions per second over last elapsed second
RLIM        limit on new sessions per second
RMAX        max number of new sessions per second
BIN         bytes in (IEEE 1541-2002)
BOUT        bytes out (IEEE 1541-2002)

In HTTP mode:

RATE        HTTP requests per second over last elapsed second
RMAX        max number of HTTP requests per second observed
RTOT        total number of HTTP requests received
1xx         number of HTTP responses with 1xx code
2xx         number of HTTP responses with 2xx code
3xx         number of HTTP responses with 3xx code
4xx         number of HTTP responses with 4xx code
5xx         number of HTTP responses with 5xx code
?xx         number of HTTP responses with other codes (protocol error)

In ERRORS mode:

CF          number of failed checks
CD          number of UP->DOWN transitions
CL          last status change
ECONN       connection errors
EREQ        request errors
ERSP        response errors
DREQ        denied requests
DRSP        denied responses
DOWN        total downtime

Health check status reference:

UNK         unknown
INI         initializing
SOCKERR     socket error
L4OK        check passed on layer 4, no upper layers testing enabled
L4TMOUT     layer 1-4 timeout
L4CON       layer 1-4 connection problem, for example
            "Connection refused" (tcp rst) or "No route to host" (icmp)
L6OK        check passed on layer 6
L6TOUT      layer 6 (SSL) timeout
L6RSP       layer 6 invalid response - protocol error
L7OK        check passed on layer 7
L7OKC       check conditionally passed on layer 7, for example 404 with
            disable-on-404
L7TOUT      layer 7 (HTTP/SMTP) timeout
L7RSP       layer 7 invalid response - protocol error
L7STS       layer 7 response error, for example HTTP 5xx
'''
__author__    = 'John Feuerstein <john@feurix.com>'
__copyright__ = 'Copyright (C) 2010 %s' % __author__
__license__   = 'GNU GPLv3'
__version__   = '0.2.0'

import os
import sys
import re
import curses

# Settings of interactive command session over the unix-socket
HAPROXY_CLI_BUFSIZE = 4096
HAPROXY_CLI_TIMEOUT = 60
HAPROXY_CLI_PROMPT = '> '

# Upper limit of content lines in the scrolling area
MAXLINES_CONTENT = 200

HAPROXY_INFO_RE = {
'software_name':    re.compile('^Name:\s*(?P<value>\S+)'),
'software_version': re.compile('^Version:\s*(?P<value>\S+)'),
'software_release': re.compile('^Release_date:\s*(?P<value>\S+)'),
'nproc':            re.compile('^Nbproc:\s*(?P<value>\d+)'),
'procn':            re.compile('^Process_num:\s*(?P<value>\d+)'),
'pid':              re.compile('^Pid:\s*(?P<value>\d+)'),
'uptime':           re.compile('^Uptime:\s*(?P<value>[\S ]+)$'),
'maxconn':          re.compile('^Maxconn:\s*(?P<value>\d+)'),
'curconn':          re.compile('^CurrConns:\s*(?P<value>\d+)'),
'maxpipes':         re.compile('^Maxpipes:\s*(?P<value>\d+)'),
'curpipes':         re.compile('^PipesUsed:\s*(?P<value>\d+)'),
'tasks':            re.compile('^Tasks:\s*(?P<value>\d+)'),
'runqueue':         re.compile('^Run_queue:\s*(?P<value>\d+)'),
'node':             re.compile('^node:\s*(?P<value>\S+)'),
'description':      re.compile('^description:\s*(?P<value>\S+)'),
}

HAPROXY_STAT_CSV = [
# Note: Fields must be listed in correct order, as described in:
# http://haproxy.1wt.eu/download/1.4/doc/configuration.txt [9.1]

# Field             Description

'pxname',           # proxy name
'svname',           # service name (FRONTEND / BACKEND / name or server name)
'qcur',             # current queued requests
'qmax',             # max queued requests
'scur',             # current sessions
'smax',             # max sessions
'slim',             # sessions limit
'stot',             # total sessions
'bin',              # bytes in
'bout',             # bytes out
'dreq',             # denied requests
'dresp',            # denied responses
'ereq',             # request errors
'econ',             # connection errors
'eresp',            # response errors (among which srv_abrt)
'wretr',            # retries (warning)
'wredis',           # redispatches (warning)
'status',           # status (UP/DOWN/NOLB/MAINT/MAINT(via)...)
'weight',           # server weight (server), total weight (backend)
'act',              # server is active (server), number of active servers (backend)
'bck',              # server is backup (server), number of backup servers (backend)
'chkfail',          # number of failed checks
'chkdown',          # number of UP->DOWN transitions
'lastchg',          # last status change (in seconds)
'downtime',         # total downtime (in seconds)
'qlimit',           # queue limit
'pid',              # process id (0 for first instance, 1 for second, ...)
'iid',              # unique proxy id
'sid',              # service id (unique inside a proxy)
'throttle',         # warm up status
'lbtot',            # total number of times a server was selected
'tracked',          # id of proxy/server if tracking is enabled
'type',             # (0=frontend, 1=backend, 2=server, 3=socket)
'rate',             # number of sessions per second over last elapsed second
'rate_lim',         # limit on new sessions per second
'rate_max',         # max number of new sessions per second
'check_status',     # status of last health check, one of:
                    #   UNK     -> unknown
                    #   INI     -> initializing
                    #   SOCKERR -> socket error
                    #   L4OK    -> check passed on layer 4, no upper layers testing enabled
                    #   L4TMOUT -> layer 1-4 timeout
                    #   L4CON   -> layer 1-4 connection problem, for example
                    #              "Connection refused" (tcp rst) or "No route to host" (icmp)
                    #   L6OK    -> check passed on layer 6
                    #   L6TOUT  -> layer 6 (SSL) timeout
                    #   L6RSP   -> layer 6 invalid response - protocol error
                    #   L7OK    -> check passed on layer 7
                    #   L7OKC   -> check conditionally passed on layer 7, for example 404 with
                    #              disable-on-404
                    #   L7TOUT  -> layer 7 (HTTP/SMTP) timeout
                    #   L7RSP   -> layer 7 invalid response - protocol error
                    #   L7STS   -> layer 7 response error, for example HTTP 5xx
'check_code',       # layer5-7 code, if available
'check_duration',   # time in ms took to finish last health check
'hrsp_1xx',         # http responses with 1xx code
'hrsp_2xx',         # http responses with 2xx code
'hrsp_3xx',         # http responses with 3xx code
'hrsp_4xx',         # http responses with 4xx code
'hrsp_5xx',         # http responses with 5xx code
'hrsp_other',       # http responses with other codes (protocol error)
'hanafail',         # failed health checks details
'req_rate',         # HTTP requests per second over last elapsed second
'req_rate_max',     # max number of HTTP requests per second observed
'req_tot',          # total number of HTTP requests received
'cli_abrt',         # number of data transfers aborted by the client
'srv_abrt',         # number of data transfers aborted by the server (inc. in eresp)
]
HAPROXY_STAT_NUMFIELDS = len(HAPROXY_STAT_CSV)

# All (possible) big numeric values on the screen are humanized using the
# metric prefix set, while everything byte related is using binary prefixes.
PREFIX_BINARY = {
        1024:    'K',
        1024**2: 'M',
        1024**3: 'G',
        1024**4: 'T',
        1024**5: 'P',
}
PREFIX_METRIC = {
        1000:    'k',
        1000**2: 'M',
        1000**3: 'G',
        1000**4: 'T',
        1000**5: 'P',
}
PREFIX_TIME = {
        60:      'm',
        60*60:   'h',
        60*60*24:'d',
}

class HAProxyStatusSocket:

    def __init__(self, path):
        self.path = path

        from socket import socket, AF_UNIX, SOCK_STREAM
        self._socket = socket(AF_UNIX, SOCK_STREAM)

        # Initialize interactive socket connection
        self.connect()
        self.send('prompt')
        self.recv()
        self.send('set timeout cli %d' % HAPROXY_CLI_TIMEOUT)
        self.recv()

    def connect(self):
        self._socket.connect(self.path)

    def close(self):
        self._socket.close()

    def send(self, data):
        self._socket.sendall('%s\n' % data)

    def recv(self):
        data = self._socket.recv(HAPROXY_CLI_BUFSIZE)
        while not data.endswith(HAPROXY_CLI_PROMPT):
            data += self._socket.recv(HAPROXY_CLI_BUFSIZE)
        return data[:(-len(HAPROXY_CLI_PROMPT))]

    def iterlines(self, command):
        self.send(command)
        return iter(self.recv().strip().splitlines())

    def get_stat(self):
        stats = {}
        for line in self.iterlines('show stat'):
            if line.count(',') != HAPROXY_STAT_NUMFIELDS:
                continue # unknown format
            if line.startswith('#'):
                continue # comment

            stat = line.split(',')
            stat = map(lambda s: s.strip(), stat)

            pxname = stat[HAPROXY_STAT_CSV.index('pxname')]
            try:
                proxy = stats[pxname]
            except KeyError:
                proxy = HAProxyStat(pxname)
                stats[pxname] = proxy
            proxy.record(stat)
        return stats

    def get_info(self):
        info = {}
        for line in self.iterlines('show info'):
            line = line.strip()
            if not line:
                continue
            for key, regexp in HAPROXY_INFO_RE.iteritems():
                match = regexp.match(line)
                if match:
                    try:
                        info[key] = int(match.group('value'), 10)
                    except:
                        info[key] = match.group('value')
                    break
        return info

class HAProxyStat:

    def __init__(self, name):
        self.pxname = name
        self.services = {}

    def record(self, stat):
        svname = stat[HAPROXY_STAT_CSV.index('svname')]
        try:
            service = self.services[svname]
        except KeyError:
            service = HAProxyServiceStat(self, svname)
            self.services[svname] = service

        for field in HAPROXY_STAT_CSV:
            if field == 'pxname' or field == 'svname':
                continue
            setattr(service, field, stat[HAPROXY_STAT_CSV.index(field)])

class HAProxyServiceStat:

    def __init__(self, proxy, name):
        self.proxy = proxy
        self.svname = name

class StatusBar:

    def __init__(self, width=60, min=0, max=100, status=True):
        self.width = width
        self.curval = min
        self.minval = min
        self.maxval = max
        self.status = status
        self.prepend = '['
        self.append = ']'
        self.usedchar = '|'
        self.freechar = ' '

    def update_cur(self, value):
        value = min(self.maxval, value)
        value = max(self.minval, value)
        self.curval = value

    def update_max(self, value):
        assert value > self.minval
        self.maxval = value

    def __str__(self):
        if self.status:
            status = '%d/%d' % (self.curval, self.maxval)

        space = self.width - len(self.prepend) - len(self.append)
        span = self.maxval - self.minval

        if self.status:
            assert self.width > (len(status) + 10)
        else:
            assert self.width > 10

        used = min(float(self.curval) / float(span), 1.0) if span else 0.0
        free = 1.0 - used

        # 100% equals full bar width, ignoring status text within the bar
        bar  = self.prepend
        bar += self.usedchar * int(space * used)
        bar += self.freechar * int(space * free)
        if self.status:
            bar  = bar[:(self.width - len(status) - len(self.append))]
            bar += status
        bar += self.append

        return bar

def log(msg):
    sys.stderr.write('%s\n' % msg)

def humanize(value, si=False, time=False):
    if not value:
        return ''
    value = long(value, 10)

    if time:
        p = PREFIX_TIME
        for minval, prefix in sorted(p.items(), reverse=True):
            if (value/minval):
                return '%d%s' % (value/minval, prefix)
        return '%ss' % value

    p = PREFIX_METRIC if si else PREFIX_BINARY
    for minval, prefix in sorted(p.items(), reverse=True):
        if (value/minval):
            return '%.1f%s' % (value/minval, prefix)
    return str(value)

def trim(l, s):
    if len(s) <= l:
        return s
    if l == 1:
        return s[0]
    if l >= 3:
        return '..%s' % s[-(l-2):]
    return '#'

def get_status(service):
    if service.status == 'no check':
        return ('-', 'none')
    return (service.status, service.check_status)

def draw_help(screen):
    screen.addstr(0, 0, __doc__)

def draw_line(screen, ypos, xpos, text=None, attr=curses.A_REVERSE):
    ymax, xmax = screen.getmaxyx()
    screen.hline(ypos, 0, ' ', xmax, attr)
    if text:
        screen.addstr(ypos, xpos, text, attr)

def draw_header(screen, info, sb_conn, sb_pipe):
    screen.addstr(2, 2,
            '%s Version: %s  (released: %s)' % (
                info['software_name'],
                info['software_version'],
                info['software_release'],
            ), curses.A_BOLD)
    screen.addstr(2, 56, 'PID: %d (proc %d)' %
            (info['pid'], info['procn']), curses.A_BOLD)

    screen.addstr(4, 2,  '       Node: %s (uptime %s)' % (
        info['node'] if info['node'] else 'unknown', info['uptime']))

    screen.addstr(6, 2,  '      Pipes: %s'  % sb_pipe)
    screen.addstr(7, 2,  'Connections: %s'  % sb_conn)
    screen.addstr(9, 2,  '  Processes: %3d' % info['nproc'])
    screen.addstr(9, 28,       'Tasks: %8d' % info['tasks'])
    screen.addstr(9, 56,   'Run Queue: %8d' % info['runqueue'])

def draw_columns(screen, mode):
    if mode == 0:       # HELP
        draw_line(screen, 11, 0, 'hatop online help',
                curses.A_REVERSE | curses.A_BOLD)
    elif mode == 1:     # STATUS
        draw_line(screen, 11, 0,
                'NAME     WEIGHT STATUS CHECK   ACT BCK  '
                'QCUR  QMAX   SCUR   SMAX   SLIM   STOT',
                curses.A_REVERSE | curses.A_BOLD)
    elif mode == 2:     # TRAFFIC
        draw_line(screen, 11, 0,
                'NAME     WEIGHT STATUS    LBTOT   '
                'RATE   RLIM   RMAX          BIN         BOUT',
                curses.A_REVERSE | curses.A_BOLD)
    elif mode == 3:     # HTTP
        draw_line(screen, 11, 0,
                'NAME     WEIGHT STATUS  RATE  RMAX    RTOT   '
                '1xx   2xx   3xx   4xx   5xx   ?xx',
                curses.A_REVERSE | curses.A_BOLD)
    elif mode == 4:     # ERRORS
        draw_line(screen, 11, 0,
                'NAME     WEIGHT STATUS CHECK    CF  CD  CL '
                'ECONN  EREQ  ERSP  DREQ  DRSP  DOWN',
                curses.A_REVERSE | curses.A_BOLD)
    elif mode == 5:     # CLI
        draw_line(screen, 11, 0)
        screen.addstr(11, 1, 'command line interface',
                curses.A_REVERSE | curses.A_BOLD)
        screen.addstr(11, 51, "enter 'help' for more info",
                curses.A_REVERSE)

def draw_footer(screen, mode, ro):
    ymax, xmax = screen.getmaxyx()
    ypos = ymax-1
    draw_line(screen, ypos, 0)
    attr_active = curses.A_BOLD
    attr_inactive = curses.A_BOLD | curses.A_REVERSE

    attr = attr_active if mode == 1 else attr_inactive
    screen.addstr(ypos,  0, ' 1-STATUS ', attr)
    attr = attr_active if mode == 2 else attr_inactive
    screen.addstr(ypos, 10, ' 2-TRAFFIC ', attr)
    attr = attr_active if mode == 3 else attr_inactive
    screen.addstr(ypos, 21, ' 3-HTTP ', attr)
    attr = attr_active if mode == 4 else attr_inactive
    screen.addstr(ypos, 29, ' 4-ERRORS ', attr)

    if not ro:
        attr = attr_active if mode == 5 else attr_inactive
        screen.addstr(ypos, 39, ' 5-CLI ', attr)

    screen.addstr(ypos, 49, 'UP/DOWN=SCROLL H=HELP Q=QUIT', attr_inactive)

def draw_service_stat(screen, ypos, service):
    status, check_status = get_status(service)
    screen.addstr(ypos, 0,
            '%s %s %s %s %s %s %s %s %s %s %s %s' % (
                trim(10, service.svname).ljust(10),
                trim(4, service.weight).rjust(4),
                trim(6, status).ljust(6),
                trim(7, check_status).ljust(7),
                trim(3, service.act).rjust(3),
                trim(3, service.bck).rjust(3),
                trim(5, humanize(service.qcur, si=True)).rjust(5),
                trim(5, humanize(service.qmax, si=True)).rjust(5),
                trim(6, humanize(service.scur, si=True)).rjust(6),
                trim(6, humanize(service.smax, si=True)).rjust(6),
                trim(6, humanize(service.slim, si=True)).rjust(6),
                trim(6, humanize(service.stot, si=True)).rjust(6),
            ))

def draw_service_traf(screen, ypos, service):
    status, check_status = get_status(service)
    screen.addstr(ypos, 0,
            '%s %s %s %s %s %s %s %s %s' % (
                trim(10, service.svname).ljust(10),
                trim(4, service.weight).rjust(4),
                trim(6, status).ljust(6),
                trim(8, humanize(service.lbtot, si=True)).rjust(8),
                trim(6, humanize(service.rate, si=True)).rjust(6),
                trim(6, humanize(service.rate_lim, si=True)).rjust(6),
                trim(6, humanize(service.rate_max, si=True)).rjust(6),
                trim(12, humanize(service.bin)).rjust(12),
                trim(12, humanize(service.bout)).rjust(12),
            ))

def draw_service_http(screen, ypos, service):
    status, check_status = get_status(service)
    screen.addstr(ypos, 0,
            '%s %s %s %s %s %s %s %s %s %s %s %s' % (
                trim(10, service.svname).ljust(10),
                trim(4, service.weight).rjust(4),
                trim(6, status).ljust(6),
                trim(5, humanize(service.req_rate, si=True)).rjust(5),
                trim(5, humanize(service.req_rate_max, si=True)).rjust(5),
                trim(7, humanize(service.req_tot, si=True)).rjust(7),
                trim(5, humanize(service.hrsp_1xx, si=True)).rjust(5),
                trim(5, humanize(service.hrsp_2xx, si=True)).rjust(5),
                trim(5, humanize(service.hrsp_3xx, si=True)).rjust(5),
                trim(5, humanize(service.hrsp_4xx, si=True)).rjust(5),
                trim(5, humanize(service.hrsp_5xx, si=True)).rjust(5),
                trim(5, humanize(service.hrsp_other, si=True)).rjust(5),
            ))

def draw_service_err(screen, ypos, service):
    status, check_status = get_status(service)
    screen.addstr(ypos, 0,
            '%s %s %s %s %s %s %s %s %s %s %s %s %s' % (
                trim(10, service.svname).ljust(10),
                trim(4, service.weight).rjust(4),
                trim(6, status).ljust(6),
                trim(7, check_status).ljust(7),
                trim(3, humanize(service.chkfail, si=True)).rjust(3),
                trim(3, humanize(service.chkdown, si=True)).rjust(3),
                trim(3, humanize(service.lastchg, time=True)).rjust(3),
                trim(5, humanize(service.econ, si=True)).rjust(5),
                trim(5, humanize(service.ereq, si=True)).rjust(5),
                trim(5, humanize(service.eresp, si=True)).rjust(5),
                trim(5, humanize(service.dreq, si=True)).rjust(5),
                trim(5, humanize(service.dresp, si=True)).rjust(5),
                trim(5, humanize(service.downtime, time=True)).rjust(5),
            ))

def draw_pad(screen, stat, callback):
    ypos = 0
    for pxname, proxy in sorted(stat.items()):
        if ypos > MAXLINES_CONTENT:
            break

        screen.addstr(ypos, 0, '>>> %s' % pxname, curses.A_BOLD)
        ypos += 1

        try:
            frontend = proxy.services.pop('FRONTEND')
        except:
            frontend = None

        try:
            backend = proxy.services.pop('BACKEND')
        except:
            backend = None

        if frontend:
            if ypos > MAXLINES_CONTENT:
                break
            callback(screen, ypos, frontend)
            ypos += 1

        for svname, service in sorted(proxy.services.items()):
            if ypos > MAXLINES_CONTENT:
                break
            callback(screen, ypos, service)
            ypos += 1

        if backend:
            if ypos >= MAXLINES_CONTENT:
                break
            callback(screen, ypos, backend)
            ypos += 1
        ypos += 1

def draw_stat(*args, **kwargs):
    kwargs.update({'callback': draw_service_stat})
    return draw_pad(*args, **kwargs)

def draw_traf(*args, **kwargs):
    kwargs.update({'callback': draw_service_traf})
    return draw_pad(*args, **kwargs)

def draw_http(*args, **kwargs):
    kwargs.update({'callback': draw_service_http})
    return draw_pad(*args, **kwargs)

def draw_err(*args, **kwargs):
    kwargs.update({'callback': draw_service_err})
    return draw_pad(*args, **kwargs)

def update_info(socket, sb_conn, sb_pipe):
    data = socket.get_info()
    sb_conn.update_max(data['maxconn'] or 100000)
    sb_conn.update_cur(data['curconn'])
    sb_pipe.update_max(data['maxpipes'] or 1000)
    sb_pipe.update_cur(data['curpipes'])
    return data

def update_stat(socket):
    return socket.get_stat()

def run_cli(pad):
    pass # TODO

def mainloop(screen, socket, interval, mode, ro):
    from time import sleep, ctime

    # Initialize curses and screen
    curses.curs_set(0)
    curses.use_default_colors()
    screen.move(0, 0)
    screen.nodelay(1)
    screen.idlok(1)

    # Initialize the scrollable content pad
    ymax, xmax = screen.getmaxyx()
    pad = curses.newpad(MAXLINES_CONTENT+2, xmax)
    padpos = 0

    # Prepare status bars
    sb_conn = StatusBar()
    sb_pipe = StatusBar()

    # sleep time of each iteration in seconds
    scan = 1.0 / 100.0
    # query socket and redraw screen in the given interval
    update = interval / scan

    hatop_version = 'hatop version %s' % __version__

    i = 0
    while 1:
        ymax, xmax = screen.getmaxyx()
        if xmax < 78 or ymax < 20:
            raise RuntimeError('Terminal too small, need at least 78x20')

        if i == 0:
            # Query the socket for new data and parse it
            data_info = update_info(socket, sb_conn, sb_pipe)
            data_stat = update_stat(socket) if str(mode) in '1234' else {}

            screen.clear()

            # Top line with hatop version and current date
            draw_line(screen, 0, 0)
            attr = curses.A_REVERSE | curses.A_BOLD
            screen.addstr(0, 0, ctime().rjust(78), attr)
            screen.addstr(0, 1, hatop_version, attr)

            # Info header, column and footer display
            draw_header(screen, data_info, sb_conn, sb_pipe)
            draw_columns(screen, mode)
            draw_footer(screen, mode, ro)

            screen.refresh()

            # Mode specific display on the pad
            pad.clear()

            if mode == 0:
                draw_help(pad)
            elif mode == 1:
                draw_stat(pad, data_stat)
            elif mode == 2:
                draw_traf(pad, data_stat)
            elif mode == 3:
                draw_http(pad, data_stat)
            elif mode == 4:
                draw_err(pad, data_stat)
            elif mode == 5:
                run_cli(pad)

            pad.refresh(padpos, 0, 13, 0, ymax-3, xmax)

            i = update

        c = screen.getch()

        if 0 < c < 256:
            c = chr(c)
            if c in 'qQ':
                break
            if c in ' ':
                i = 0
                continue
            if c in 'Hh?':
                i = mode = 0
                continue
            if c in '1':
                i, mode = 0, 1
                continue
            if c in '2':
                i, mode = 0, 2
                continue
            if c in '3':
                i, mode = 0, 3
                continue
            if c in '4':
                i, mode = 0, 4
                continue
            if c in '5' and not ro:
                i, mode = 0, 5
                continue
        elif c == curses.KEY_UP and padpos > 0:
            padpos -= 1
            pad.refresh(padpos, 0, 13, 0, ymax-3, xmax)
        elif c == curses.KEY_DOWN and padpos < (MAXLINES_CONTENT-ymax):
            padpos += 1
            pad.refresh(padpos, 0, 13, 0, ymax-3, xmax)

        sleep(scan)
        i -= 1


if __name__ == '__main__':

    from optparse import OptionParser

    version  = 'hatop version %s' % __version__
    usage    = 'Usage: hatop [options]'

    parser = OptionParser(usage=usage, version=version)

    parser.add_option('-s', '--unix-socket', type='str', dest='socket',
            help='path to the haproxy unix socket (mandatory)')
    parser.add_option('-n', '--read-only', action='store_true', dest='ro',
            help='disable the cli and query for stats only')
    parser.add_option('-i', '--update-interval', type='int', dest='interval',
            help='update interval in seconds (1-30s, default: 1s)', default=1)
    parser.add_option('-m', '--mode', type='int', dest='mode',
            help='start in specific mode (1-5, default: 1)', default=1)

    opts, args = parser.parse_args()

    if not 0 < opts.interval < 31:
        log('invalid update interval: %d' % opts.interval)
        sys.exit(1)
    if not 0 < opts.mode < 6:
        log('invalid mode: %d' % opts.mode)
        sys.exit(1)
    if opts.ro and opts.mode == 5:
        log('cli not available in read-only mode')
        sys.exit(1)
    if not opts.socket:
        parser.print_help()
        sys.exit(0)
    if not os.access(opts.socket, os.R_OK | os.W_OK):
        log('insufficient permissions for path %s' % opts.socket)
        sys.exit(2)

    try:
        socket = HAProxyStatusSocket(opts.socket)
    except:
        raise

    try:
        curses.wrapper(mainloop, socket, opts.interval, opts.mode, opts.ro)
    finally:
        socket.close()

# vim: et sw=4 tw=78 fdn=1 fdm=indent
